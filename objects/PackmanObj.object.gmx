<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>Packman_spr</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>keyboard_set_map(ord('W'),vk_up);
keyboard_set_map(ord('A'),vk_left);
keyboard_set_map(ord('S'),vk_down);
keyboard_set_map(ord('D'),vk_right);

random_set_seed(66);

image_speed = 0;
frame = 0;
dir = 2;
maxspeed = 1;
lasttile = noone;
SpeedNow = 0;
Invincible = false;

BlueScore =200;
hspeed = -maxspeed;
instance_create(0,0,GhostsSpawnObj); // Used to initialize some variables the ghosts use.


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!Invincible)
{
Invincible = true;
image_alpha = 0.3;
}
else
{
Invincible = false;
image_alpha = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>atepellet = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if packman is moving, decide the animation sequence in the subframes
if(speed&gt;0)
{
    frame = ((direction/360) * 8) + 1;
}


AnimatePart(frame,(frame&gt;0) *2)
//(frame&gt;0) *2 passes 0 or 2, if first frame, the start circle, pass 0, 
//else, pass 2, this is a quick was to decide between o and 2

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//show_debug_message(string(instance_number(PausedObj)))
if(instance_exists(PausedObj)) exit;


// This code checks to see if Pacman ate a pellet, then keeps his dot speed for 10 steps before he returns to his normal speed.

if (atepellet = 0)
{
SpeedNow = PacSpeed;
speed = PacSpeed;
}
else if (atepellet = 1 and alarm[0] &lt;= 0)
{
SpeedNow = PacDotsSpeed;
speed = PacDotsSpeed;
alarm[0] = 10;
}


//what direction is asked
hs = (keyboard_check_pressed(vk_right) - keyboard_check_pressed(vk_left));
vs = (keyboard_check_pressed(vk_down) - keyboard_check_pressed(vk_up));

if(hs == 0 and vs == 0)
{
    hs = (keyboard_check(vk_right) - keyboard_check(vk_left));
    vs = (keyboard_check(vk_down) - keyboard_check(vk_up));
}

//Pellets
with(instance_nearest(x-6,y-6,PelletObj))
{
    if(point_distance(x,y,other.x-6,other.y-6) &lt; 8)
    {
        score +=10;
        audio_play_sound(Pellet_snd, 0, false);
        instance_destroy();
        atepellet = 1;
        SpeedNow = PacDotsSpeed;
        speed = PacDotsSpeed;
        
        if (GhostCountersDisabled = 0)
        {
            if (!PinkyLeftHouse)
            PinkyDotCounter +=1;
            else if (PinkyLeftHouse and !InkyLeftHouse)
            InkyDotCounter +=1;
            else if (InkyLeftHouse and !ClydeLeftHouse)
            ClydeDotCounter +=1;
        }
        else
        GlobalDotCounter +=1;
    }
    
}

//Pills
with(instance_nearest(x-6,y-6,PillObj))
{
    if(point_distance(x,y,other.x-6,other.y-6) &lt; 8)
    {
        score +=50;
        BlueGhostScore = 200;
        audio_play_sound(Pellet_snd, 0, false);
        instance_destroy();
        
        with(ParentGhostObj) 
        {
            if(FrightTime)
            {
                if(object_index != BlueGhostObj and object_index != GhostEyesObj)
                {
                    WhatIDid = current_script;
                    WhoIWas = object_index;
                    if(object_index != GhostEyesObj) 
                    {
                        GhostFlipDirection()
                        instance_change(BlueGhostObj,1);
                    }
                }
                else if (object_index = BlueGhostObj)
                {
                    GhostFlipDirection()
                    event_perform(ev_create, 0);
                    sprite_index = BlueGhost_spr
                }
            }
            else
            {
                if(object_index != BlueGhostObj and object_index != GhostEyesObj)
                    GhostFlipDirection();
            }
        }
        atepellet = 1;
        SpeedNow = PacDotsSpeed;
        speed = PacDotsSpeed;
    }
}


//OK, so did player have a key down, hs or vs is set to -1 or 1m not 0
    
    
    //round((x-6)/12)+6+hs*12,round((y-6)/12)+6+vs*12,10)
        //ShowXY(round((x-6)/12)*12+6+hs*12,round((y-6)/12)*12+6+vs*12,10);
if(abs(hs) != abs(vs))
{
    //get the direction in 0,1,2,3 format
    var newdir; newdir = floor(point_direction(0,0,hs,vs)/90); 
    //compare with old direction, detect change in direction
    if(newdir &lt;&gt; dir)
    {
        //look at desired location, to the next tile (hs*12, vs *12) does the offset
        tile = collision_point(round((x-6)/12)*12+6+hs*12,round((y-6)/12)*12+6+vs*12,TileObj,0,0)
        if(tile!=noone)
        {
            if(tile.PacDirs[newdir] == 1)
            {
                //there is a tile
                //remember new direction
                dir = newdir;
                //set the movement to speed
                hspeed = hs*SpeedNow;
                vspeed = vs*SpeedNow; 
            }
        }
    }
}

//go to center of the road on x when updown, on y when left right
//what tile are we on (closest)
tileon = collision_point(round((x-6)/12)*12+6,round((y-6)/12)*12+6,TileObj,0,0);
if(tileon != noone) lasttile = tileon;
if(lasttile != noone)
{
    //if left right movement
    if(dir == 0 or dir == 2)
    {
        //smooth move to tile axis
        dif = lasttile.y + 6 - y;
        y+=min(SpeedNow,abs(dif)) * sign(dif)
        //or instant like the real game
        //y = lasttile.y + 6
    }
    else //up down
    {
        //smooth move to tile axis
        dif = lasttile.x + 6 - x;
        x+=min(SpeedNow,abs(dif)) * sign(dif)
        //or instant like the real game
        //x = lasttile.x + 6
    }
}
//finaly, stop if no tile in the moving direction
//if(speed&gt;0)
{
//this animates at .25 when speed is not 0
//0 image speed when speed is 0
    image_speed = .25 * (speed&gt;0);

    //position to look at,
    xx = round(x)+sign(hspeed) * 10;// floor((x-6)/12)*12+6+sign(hspeed) * 7;
    yy = round(y)+sign(vspeed) * 10;//floor((y-6)/12)*12+6+sign(vspeed) * 7;
    //ShowXY(xx,yy,10)
    //with(lasttile) 
    //{
    //x -= 1000000
    //}
    //xx = (x/12)*12+sign(hspeed) * 13;
    //yy = (y/12)*12+sign(vspeed) * 13;
    if(!collision_circle(xx,yy,3,TileObj,0,0)) 
    {
        //speed = 0;
        if(tileon )
        {
            x = tileon.x+6;
            y = tileon.y+6;
            //this animates at .25 when speed is not 0
            //0 image speed when speed is 0
            image_speed = 0;

        }
    }
    //with(lasttile) 
    //{
    //x += 1000000;
    //}
}


//other confusion galore, simpler to use var
var pacid; pacid = id;
//Ghosts
var pt,xx,yy; 
pt = 0;

if (!Invincible)
with(instance_nearest(x,y,ParentGhostObj))
{
    if(point_distance(x,y,pacid.x,pacid.y) &lt; 8)
    {
        if(object_index == BlinkyObj or object_index == InkyObj
        or object_index == PinkyObj or object_index == ClydeObj)
        {
            instance_create(pacid.x,pacid.y,PauseAndDieObj);
            with(LevelInfoObj)
            alarm[0] = -1; // Stop the dot timer
        }
        //blue ghost
        else if(object_index == BlueGhostObj)
        {
            pt = BlueGhostScore;
            //add points
            score += pt;
            //double it for next time
            BlueGhostScore *=2;
            BlueGhostScore  = min(1600,BlueGhostScore);
            audio_play_sound(EatBlueGhost_snd, 0, false);
            
            //pacid.x -= pacid.hspeed * (1-0);
            //pacid.y -= pacid.vspeed * (1-0);
            with(instance_create(x,y,GhostEyesObj))
            {
                WhoIWas = other.WhoIWas;
                xstart = other.xstart;
                ystart = other.ystart;
                HomeTile = collision_point(other.xstart,other.ystart,TileObj,0,0);
            }
            
            xx = x;
            yy = y;
            instance_destroy();
        }
    }
}

            //show the points, paused
if(pt)
    with(instance_create(xx,yy,PointOnSpotPausedObj))
    {
        points = pt;
    }
    
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// an alarm is necessary so that if the player presses space at the start screen, it doesn't throw an error that the invincible variable doesn't exists (as Pacman hasn't been created yet).
alarm[1] = 1;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Essentially a finish maze cheat

with(PelletObj)
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>11,11</point>
    <point>12,12</point>
  </PhysicsShapePoints>
</object>
